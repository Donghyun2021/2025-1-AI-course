# -*- coding: utf-8 -*-
"""assignment1_RetinaNet_ver2_2021071876.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17RdDnS-a1DYPq9D6IoyZ7f4mdBJNyAIr

### Libraries
"""

!pip install wget
import wget

!pip show numpy

from __future__ import print_function, division
import os
import torch
import numpy as np
import random

from torch.utils.data import DataLoader
from torch.utils.data.sampler import Sampler
from torchvision.datasets import VOCDetection

import tarfile

import skimage.io
import skimage.transform
import skimage.color
import skimage

from torchvision import transforms

from PIL import Image
import xml.etree.ElementTree as ET

import torch.optim as optim

import numpy as np
import matplotlib.pyplot as plt
from torchvision.transforms.functional import to_pil_image
from PIL import ImageDraw, ImageFont

import torch.nn as nn
import torch

import math
import torch.utils.model_zoo as model_zoo
from torchvision.ops import nms

"""## Load dataset: VOC2007
---
### Complete the following transformation modules
* Normalizer: Implement a Normalizer that normalizes an image using the RGB mean and standard deviation.
* Augmenter: Implement an Augmenter that horizontally flips an image with a 0.5 probability.
"""

class Resizer(object): #이미지 크기 조절
    """Convert ndarrays in sample to Tensors."""

    def __call__(self, sample, min_side=608, max_side=1024): #retinaNet은 보통 C3,C4,C5 3개의 Conv블럭을 사용
        # -> 32의 배수를 size로 설정해야 featuremap의 크키가 1/2씩 줄어드는 구조속에서 C5가 정수로 떨어질 수 있음.
        image, annots = sample['img'], sample['annot']

        rows, cols, cns = image.shape # shape is tuple type

        smallest_side = min(rows, cols)

        # rescale the image so the smallest side is min_side
        scale = min_side / smallest_side

        # check if the largest side is now greater than max_side, which can happen
        # when images have a large aspect ratio
        largest_side = max(rows, cols)

        if largest_side * scale > max_side:
            scale = max_side / largest_side

        # scale : 이미지를 몇배 확대할 것인가 -> 이미지가 너무 작지 않도록 해주기 위함.
        # ex) 이미지 사이즈 500x1200 -> 사이즈 1.216배 확대(608/500)(작은쪽 기준으로 먼저 계산) -> 사이즈 0.8533배로 줄임(큰쪽 기준 계산)
        # 주의) 이때 1.216의 scale은 무효화됨.


        # resize the image with the computed scale
        image = skimage.transform.resize(image, (int(round(rows*scale)), int(round((cols*scale)))))
        image = image.astype(np.float32)
        rows, cols, cns = image.shape


        pad_w = 32 - rows%32
        pad_h = 32 - cols%32
        #변을 32의 배수로 맞춰주고 남은 부분을 0으로 padding하기 위함.

        new_image = np.zeros((rows + pad_w, cols + pad_h, cns)).astype(np.float32)
        new_image[:rows, :cols, :] = image.astype(np.float32)

        annots[:, :4] *= scale
        # 모든 행에 대해 첫 4개 열만 scale배해라. -> annots(bbox) : [xmin, ymin, xmax, ymax, label]co

        return {'img': torch.from_numpy(new_image), 'annot': torch.from_numpy(annots), 'scale': scale}


class Augmenter(object):
    def __call__(self, sample, flip_x=0.5):
        #################################
        # TODO: complete this module.
        #################################
        # Augmenter is a module that augments the training set.
        # Implement and use an Augmentor that includes at least horizontal flipping with probability 0.5 -> 0,5확률로 뒤집어라 (좌우로)
        # as part of the augmentation process.

        # [START]
        image, annots = sample['img'], sample['annot']

        if np.random.rand() < flip_x:
            image = image[:, ::-1, :]  # x축 대칭

            if annots.shape[0] > 0: #bbox가 존재할때
              old_xmin = annots[:,0]
              old_xmax = annots[:,2]

              annots[:, 0] = image.shape[1] - old_xmax
              annots[:, 2] = image.shape[1] - old_xmin

        return {'img': image, 'annot': annots }
        # [END]

class Normalizer(object):
#주의) Normalization(정규화)는 두가지 종류가 있음.
  # 1) min-max Normalization : → 이미지가 0~255인 raw pixel 값을 0~1로 맞추는 것
  # 2) standardization(표준화) : 모델이 더 안정적으로 학습할 수 있도록 분포를 "평균 0, 표준편차 1"로 맞추는 것
    def __init__(self):
        self.mean = np.array([[[0.485, 0.456, 0.406]]])
        self.std = np.array([[[0.229, 0.224, 0.225]]])

    def __call__(self, sample):
      #################################
        # TODO: complete this module. #
        #################################
        # Implement a Normalizer that normalizes an image using the RGB mean and standard deviation.

        # [START]

      image, annots = sample['img'], sample['annot']
      image = (image.astype(np.float32) - self.mean) / self.std
      #numpy가 알아서 [0.485, 0.456, 0.406]를 (H,W,C)크키로 확장해서 연산을 수행 = broadcasting
      #astpye: numpy array의 데이터타입을 바꿔주는 함수 -> 배열의 데이터타입이 int64에서 float32로 바뀜.

      return {'img': image, 'annot': annots }

      # [END]
class UnNormalizer(object):
    def __init__(self, mean=None, std=None):
        if mean == None:
            self.mean = [0.485, 0.456, 0.406]
        else:
            self.mean = mean
        if std == None:
            self.std = [0.229, 0.224, 0.225]
        else:
            self.std = std

    def __call__(self, tensor):

        """
        Args:
            tensor (Tensor): Tensor image of size (C, H, W) to be normalized.
        Returns:
            Tensor: Normalized image.
        """
        for t, m, s in zip(tensor, self.mean, self.std):
            t.mul_(s).add_(m)
        return tensor

"""## VOC Dataset
---
Automatically download and use the VOC2007 dataset if it is not available.    
Complete the VOCDataset class.
"""

def VOC_download(root_dir, year="2007"):
    if os.path.exists(os.path.join(root_dir, 'VOCdevkit')):
        print("VOC exists.")
        return # 함수가 바로 종료되고 none을 반환

    urls = {
        "2007": {
            "trainval": "http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtrainval_06-Nov-2007.tar",
            "test": "http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtest_06-Nov-2007.tar"
        },
    } #year를 기준으로 다른 url도 추가할 수 있게 딕셔너리 형태로 설계

    if year not in urls:
        raise ValueError("Only VOC 2007 and 2012 are supported")

    trainval_download_path = os.path.join(root_dir, f"VOC{year}.tar")
    #path: 폴더/파일명까지 포함된 전체 경로 -> 그래서 path라고 네이밍

    print(f"Downloading VOC {year} train/val data...")
    wget.download(urls[year]["trainval"], trainval_download_path)
    #wget: 파이썬에서 외부파일을 url로 다운로드할 수 있게 해주는 라이브리

    with tarfile.open(trainval_download_path, "r") as tar:
        tar.extractall(root_dir)
        #tarfile: 압축파일을 다루는 표준라이브러리 (압축하기, 압출풀기)
        #tar: 압축파일확장자 (주로 리눅스에서 많이 씀)
        #단, 여기서의 tar은 생성된 객체

    os.remove(trainval_download_path)
    #tar파일: 택배상자와 같음 -> 압축이 해체되면 택배박스는 필요가 없어짐 -> 삭제

    if year == "2007":
        test_download_path = os.path.join(root_dir, f"VOC{year}_test.tar")
        print(f"\nDownloading VOC {year} test data...")
        wget.download(urls[year]["test"], test_download_path)
        # voc2007은 다른 연도와 달리 train set과 test set을 따로 제공.

        with tarfile.open(test_download_path, "r") as tar:
            tar.extractall(root_dir)
            # extractall: 압축해제

        os.remove(test_download_path)


class VOCDataset(VOCDetection):
    def __init__(self, root_dir, year="2007", image_set="trainval", transform=False, download=True):
      self.root_dir = root_dir
      self.year = year
      self.image_set = image_set

      if download:
          VOC_download(root_dir=self.root_dir, year=self.year)

      if transform:
      # transform=False로 디폴트 값을 설정해놓은 이유: transform이 자동으로 켜지는 걸 방지하고 train/test에 서로 다른 transform을 적용하기 위해
      # Augmenter는 trainval에만 들어가야하니까
          if image_set == 'trainval':
              self.transform = transforms.Compose([Normalizer(), Augmenter(), Resizer()])
              # transform chain : Normalizer -> Augmenter -> Resizer
              # trainval에만 augmenter를 적용하는 이유
              # 데이터 증강의 목적 : 과적합(overfitting)방지 -> 과적합은 트레이닝셋과 밀접한 연관이 있음.
          elif image_set == 'test':
              self.transform = transforms.Compose([Normalizer(), Resizer()])

      imageset_file = os.path.join(self.root_dir, "VOCdevkit", "VOC"+self.year, "ImageSets", "Main", image_set + ".txt")

      ############################################################################
      # TODO: assign appropriate values to 'self.image_ids' and 'self.classes'   #
      ############################################################################
      # self.image_ids: A list containing image names as elements.
      # self.classes: Class names defined in the order they exist in the VOC dataset.
      # [START]

      self.image_ids = []
      with open(imageset_file,'r') as f:
        for line in f:
          self.image_ids.append(line.strip())

      self.classes = [
  'aeroplane', 'bicycle', 'bird', 'boat', 'bottle',
  'bus', 'car', 'cat', 'chair', 'cow',
  'diningtable', 'dog', 'horse', 'motorbike', 'person',
  'pottedplant', 'sheep', 'sofa', 'train', 'tvmonitor'
  ]


      self.class_to_ind = dict(zip(self.classes, range(len(self.classes))))
      # [('aeroplane', 0), ('bicycle', 1), ('bird', 2), ..., ('dog', 11), ('person', 14)]이렇게 됨.

      # [END]


    def num_classes(self):
        return len(self.classes)


    def __len__(self):
        return len(self.image_ids)


    def __getitem__(self, idx):
        image_id = self.image_ids[idx]

        image_path = os.path.join(self.root_dir, "VOCdevkit", "VOC"+self.year, "JPEGImages", image_id + ".jpg")
        img = Image.open(image_path).convert("RGB")
        # convert("RGB"): PIL.Image 라이브러리 메서드 : 이미지 색상 모드를 강제로 RGB로 변환
        # VOC 데이터셋의 이미지들은 대부분 RGB 이미지지만, 가끔 흑백이미지처럼 다른 색상모드로 저장된 것도 있기 때문.
        img = np.array(img).astype(np.float32) / 255.0
        #255로 나누는 이유: 이미지파일은 일반적으로 픽셀 값이 0~255 사이의 정수로 저장되는데,
        #딥러닝 모델은 0~1사이의 normarlize된 데이터를 기대함.

        annotation_path = os.path.join(self.root_dir, "VOCdevkit", "VOC"+self.year, "Annotations", image_id + ".xml")
        tree = ET.parse(annotation_path)
        root = tree.getroot()

        annots = []
        #################################################
        # TODO: assign appropriate values to 'annots'   #
        #################################################
        # [START]

        for obj in root.findall('object'):
          # XML은 반복태그를 리스트처럼 처리하기 때문에,
          # findall함수사용시 내부적으로 [object1, object2, ...] 이런식으로 리스트를 만들줌
          class_name = obj.find('name').text
          if class_name is None or obj.find('name').text.lower().strip() not in self.class_to_ind:
            print(f"Warning: Skipping object with invalid class name: {class_name}")
            continue

          bbox = obj.find('bndbox')
          # find는 findall과 다르게 맨처음 등장하는 태그만 반환 -> 처음 등장하는 object 하나만 반환

          xmin = float(bbox.find('xmin').text) - 1
          ymin = float(bbox.find('ymin').text) - 1
          xmax = float(bbox.find('xmax').text) - 1
          ymax = float(bbox.find('ymax').text) - 1
          #VOC의 XML파일 안에서는 좌표가 1부터 기록되어 있음.
          #하지만 딥러닝/컴퓨터비전에서 bounding box좌표는 보통 0부터 시작함 ->  그래서 맞춰주는 거임.

          label_idx = self.class_to_ind[class_name]
          #label_idx = VOC 클래스의 정수형 인덱스 번호로 저장
          one_annot = [xmin, ymin, xmax, ymax, label_idx]
          annots.append(one_annot)
          #무슨 차이인가?

        annots = np.array(annots, dtype=np.float32)

        # [END]

        sample = {'img': img, 'annot': annots}

        if self.transform:
            sample = self.transform(sample)

        return sample
#1. Dataset에서 반환된 sample (dict)
#  └── sample = {
#       'img': numpy array (H, W, C),
#       'annot': tensor (N, 5) -> [xmin, ymin, xmax, ymax, label(클래스번호)]
#      }

    def image_aspect_ratio(self, idx):
        image_id = self.image_ids[idx]
        image_path = os.path.join(self.root_dir, "VOCdevkit", "VOC"+self.year, "JPEGImages", image_id + ".jpg")
        img = Image.open(image_path)
        return float(img.width) / float(img.height)


class AspectRatioBasedSampler(Sampler):
#비슷한 image끼리 batch로 묶어주는 역할을 함.
    def __init__(self, data_source, batch_size, drop_last):
      self.data_source = data_source #여기에 dataset_train이 들어감.
      self.batch_size = batch_size
      self.drop_last = drop_last
      self.groups = self.group_images()

    def __iter__(self):
      random.shuffle(self.groups)
      for group in self.groups:
          yield group

    def __len__(self):
        if self.drop_last:
            return len(self.data_source) // self.batch_size
        else:
            return (len(self.data_source) + self.batch_size - 1) // self.batch_size

    def group_images(self):
        # determine the order of the images
        order = list(range(len(self.data_source)))
        order.sort(key=lambda x: self.data_source.image_aspect_ratio(x))

        # divide into groups, one group = one batch
        return [[order[x % len(order)] for x in range(i, i + self.batch_size)] for i in range(0, len(order), self.batch_size)]
        #image ratio가 비슷한 이미지끼리 batch로 묶어서 효율적 학습 유도

path2data = '/content/VOC'
if not os.path.exists(path2data):
    os.mkdir(path2data)

dataset_train = VOCDataset(root_dir=path2data, year="2007", image_set="trainval", transform=True)
dataset_val = VOCDataset(root_dir=path2data, year="2007", image_set="test", transform=True)

"""## Visualization
---
Let's examine how the ground truth data is structured.
"""

##########################
# TODO: get 'classes'    #
##########################
# [START]

classes = [
    'aeroplane', 'bicycle', 'bird', 'boat', 'bottle',
    'bus', 'car', 'cat', 'chair', 'cow',
    'diningtable', 'dog', 'horse', 'motorbike', 'person',
    'pottedplant', 'sheep', 'sofa', 'train', 'tvmonitor'
    ]

# [END]

colors = np.random.randint(0, 255, size=(len(classes), 3), dtype='uint8')
#각 클래스에 대해 랜덤 색상을 생성, uint8(8비트짜리 unsigned int)

def show_sample(sample, classes=classes, colors=colors, GT=True, model=None):
    # permute (H, W, C) => (C, H, W)
    img = sample['img']
    img = img.permute(2, 0, 1) # (C, H, W)

    unorm = UnNormalizer()
    img = unorm(img.clone())
    img = torch.clamp(img, 0, 1)

    pil_img = to_pil_image(img)
    draw = ImageDraw.Draw(pil_img)

    if GT:
        annot = sample['annot']
        if torch.is_tensor(annot):
            annot = annot.cpu().numpy()

        for box in annot:
            if box[0] < 0:
                continue
            x1, y1, x2, y2, cls_idx = box
            cls_idx = int(cls_idx)
            color = tuple(int(c) for c in colors[cls_idx])
            label = classes[cls_idx]
            draw.rectangle([x1, y1, x2, y2], outline=color, width=5)
            draw.text((x1, y1), label, fill=color)
            # font = ImageFont.truetype("arial.ttf", 20)
            # draw.text((x1, y1), label, fill=color, font=font)
    else:
        with torch.no_grad():
            model.eval()
            finalScores, finalAnchorBoxesIndexes, finalAnchorBoxesCoordinates = model(img.unsqueeze(0).cuda().float())
            finalScores = finalScores.cpu()
            finalAnchorBoxesIndexes = finalAnchorBoxesIndexes.cpu()
            finalAnchorBoxesCoordinates = finalAnchorBoxesCoordinates.cpu()

            for score, cls_idx, box in zip(finalScores, finalAnchorBoxesIndexes, finalAnchorBoxesCoordinates):
                x1, y1, x2, y2 = box.int().tolist()
                cls_idx = int(cls_idx)
                color = tuple(int(c) for c in colors[cls_idx])
                label = classes[cls_idx]
                draw.rectangle([x1, y1, x2, y2], outline=color, width=5)
                draw.text((x1, y1), f'{label}-{score}', fill=color)

    plt.figure(figsize=(10, 10))
    plt.imshow(np.array(pil_img))
    plt.axis('off')
    plt.show()

sample = dataset_val[3]
show_sample(sample)

"""### Dataloaders & collater function
---
The VOC dataset comprises samples containing images of various sizes and a variable number of bounding boxes. We process this dataset in batches, and to handle samples with different formats, we implement and utilize a collater function. For more details, refer to the [official PyTorch documentation](https://pytorch.org/docs/stable/data.html#loading-batched-and-non-batched-data).

collater function : 서로 다른 크기를 가진 샘플들의 사이즈를 제로패딩을 통해 하나로 통일하는 것.

Q. 왜 사이즈를 통일해야 하는가? 그리고 왜 배치사이즈가 1이면 collater적용이 필요없는가?

A. 배치사이즈가 1이면 단일샘플 하나만 dataloader가 가져오기 때문에 굳이 다른샘플과 shap을 맞출필요가 없음. 그러나 배치사이즈가 2이상이 되게 되면 샘플 2개를 가져와야되는데, 만약 가져온 샘플 2개의 사이즈가 다르면 배치로 묶을(=stack)수 없음.
"""

def collater(data):
    imgs = [s['img'] for s in data]
    # data 안의 sample 하나씩 꺼내서, 그 sample['img'](value가 tensor)만 리스트로 모아라 (밑에도 똑같음)
    annots = [s['annot'] for s in data]
    scales = [s['scale'] for s in data]

    #permute되기전에도 (H,W,C)인데 여기서는 왜 (W,H,C)형태인거지?
    widths = [int(s.shape[0]) for s in imgs]
    heights = [int(s.shape[1]) for s in imgs]
    batch_size = len(imgs)

    max_width = np.array(widths).max()
    max_height = np.array(heights).max()

    padded_imgs = torch.zeros(batch_size, max_width, max_height, 3)

    for i in range(batch_size):
        img = imgs[i]
        padded_imgs[i, :int(img.shape[0]), :int(img.shape[1]), :] = img

    max_num_annots = max(annot.shape[0] for annot in annots)

    if max_num_annots > 0:
        annot_padded = torch.ones((len(annots), max_num_annots, 5)) * -1
        for idx, annot in enumerate(annots):
            if annot.shape[0] > 0:
              annot_padded[idx, :annot.shape[0], :] = annot
    else:
        annot_padded = torch.ones((len(annots), 1, 5)) * -1

    padded_imgs = padded_imgs.permute(0, 3, 1, 2)
    #padded_imgs = (batch_size, H, W, C) -> (batch_size, C, H, W)로 변경됨.

    #################################################
    # TODO: complete return                         #
    #################################################
    # [START]

    return {'img': padded_imgs, 'annot': annot_padded, 'scale': torch.tensor(scales)}

    # [END]

# Adjust the batch size to suit your GPU environment.
# Select the largest possible batch size that your GPU memory allows. The choice is yours.
BATCH_SIZE = 2

#########################################################################
# TODO: Initialize dataloader_train and dataloader_val with collater()  #
#########################################################################
# [START]

sampler = AspectRatioBasedSampler(dataset_train, batch_size=BATCH_SIZE, drop_last=False)
dataloader_train = DataLoader(dataset_train, num_workers=2, collate_fn=collater, batch_sampler=sampler)

sampler_val = AspectRatioBasedSampler(dataset_val, batch_size=1, drop_last=False)
dataloader_val = DataLoader(dataset_val, num_workers=2, collate_fn=collater, batch_sampler=sampler_val)

# [END]

"""## Implementation of RetinaNet
---
[Paper: Focal Loss for Dense Object Detection](https://arxiv.org/pdf/1708.02002)    
[Paper: Feature Pyramid Networks for Object Detection](https://arxiv.org/pdf/1612.03144)    
The RetinaNet model is a one-stage object detection model incorporating features such as Focal Loss, a Feature Pyramid Network (FPN), and various architectural improvements. These enhancements provide a unique balance between speed and accuracy, making RetinaNet a unique model.

Object detection, a core task in computer vision, involves finding and classifying objects within images or videos. This underpins applications like self-driving cars, security surveillance, and augmented reality.

Our goal is to implement RetinaNet, train it on the VOC dataset, and perform object detection on the test set using our model. RetinaNet consists of a pretrained backbone (ResNet101 is used in this assignment), a Feature Pyramid Network, a classification subnetwork, and a regression subnetwork. The classification model classifies which class an object belongs to, while the regression model performs bounding-box regression. RetinaNet utilizes an FPN to generate feature maps of different resolutions, enabling effective detection of objects ranging from small to large. FPN takes as input the feature maps extracted from the last three stages (C3, C4, and C5) of ResNet, and based on these, it constructs a five-level multi-scale feature pyramid (P3–P7), which are then passed to the classification and regression models. The classification model predicts the class of each anchor, while the regression model predicts the offset for each anchor.

![Screenshot 2025-03-18 at 1.23.47 PM.png](data:image/png;base64,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)
"""

#########################################
# TODO: complete this PyramidFeatures   #
# upsample mode: nearest                #
#########################################
# [START]
import torch.nn.functional as F

class PyramidFeatures(nn.Module):
    def __init__(self, C3_size, C4_size, C5_size, feature_size=256):
        super(PyramidFeatures, self).__init__()

        self.P5_1 = nn.Conv2d(C5_size, feature_size, kernel_size=1, stride=1, padding=0)
        self.P5_upsample = nn.Upsample(scale_factor=2, mode='nearest')
        self.P5_2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, stride=1, padding=1)

        self.P4_1 = nn.Conv2d(C4_size, feature_size, kernel_size=1, stride=1, padding=0)
        self.P4_upsample = nn.Upsample(scale_factor=2, mode='nearest')
        self.P4_2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, stride=1, padding=1)

        self.P3_1 = nn.Conv2d(C3_size, feature_size, kernel_size=1, stride=1, padding=0)
        self.P3_2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, stride=1, padding=1)

        self.P6 = nn.Conv2d(C5_size, feature_size, kernel_size=3, stride=2, padding=1)
        self.P7 = nn.Conv2d(feature_size, feature_size, kernel_size=3, stride=2, padding=1)

    def forward(self, inputs):

        C3, C4, C5 = inputs[0], inputs[1], inputs[2]

        P5_x = self.P5_1(C5)
        P5_upsampled = self.P5_upsample(P5_x)
        P5 = self.P5_2(P5_x)

        P4_x = self.P4_1(C4) + P5_upsampled
        P4_upsampled = self.P4_upsample(P4_x)
        P4 = self.P4_2(P4_x)

        P3_x = self.P3_1(C3) + P4_upsampled
        P3 = self.P3_2(P3_x)

        P6 = self.P6(C5)
        P7 = self.P7(F.relu(P6))

        return [P3, P4, P5, P6, P7]

# [END]

#########################################
# TODO: complete this RegressionModel   #
#########################################
# [START]

class RegressionModel(nn.Module):
    def __init__(self, num_features_in, num_anchors=9, feature_size=256):
        super(RegressionModel, self).__init__()

        self.conv1 = nn.Conv2d(num_features_in, feature_size, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1)
        self.conv3 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1)
        self.conv4 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1)
        self.output = nn.Conv2d(feature_size, num_anchors * 4, kernel_size=3, padding=1)

        self.relu = nn.ReLU()

    def forward(self, x):
        out = self.relu(self.conv1(x))
        out = self.relu(self.conv2(out))
        out = self.relu(self.conv3(out))
        out = self.relu(self.conv4(out))
        out = self.output(out)

        out = out.permute(0, 2, 3, 1)
        return out.contiguous().view(out.shape[0], -1, 4)

# [END]

#############################################
# TODO: complete this ClassificationModel   #
#############################################
# [START]

class ClassificationModel(nn.Module):
    def __init__(self, num_features_in, num_classes=20, num_anchors=9, feature_size=256):
        super(ClassificationModel, self).__init__()

        self.conv1 = nn.Conv2d(num_features_in, feature_size, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1)
        self.conv3 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1)
        self.conv4 = nn.Conv2d(feature_size, feature_size, kernel_size=3, padding=1)
        self.output = nn.Conv2d(feature_size, num_anchors * num_classes, kernel_size=3, padding=1)

        self.relu = nn.ReLU()
        self.num_classes = num_classes
        self.num_anchors = num_anchors

    def forward(self, x):
        out = self.relu(self.conv1(x))
        out = self.relu(self.conv2(out))
        out = self.relu(self.conv3(out))
        out = self.relu(self.conv4(out))
        out = self.output(out)

        out = out.permute(0, 2, 3, 1)
        out = out.contiguous().view(out.shape[0], -1, self.num_classes)
        return out

# [END]

model_urls = {
    'resnet18': 'https://download.pytorch.org/models/resnet18-5c106cde.pth',
    'resnet34': 'https://download.pytorch.org/models/resnet34-333f7ec4.pth',
    'resnet50': 'https://download.pytorch.org/models/resnet50-19c8e357.pth',
    'resnet101': 'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth',
    'resnet152': 'https://download.pytorch.org/models/resnet152-b121ed2d.pth',
}

def conv3x3(in_planes, out_planes, stride=1):
    """3x3 convolution with padding"""
    return nn.Conv2d(in_planes, out_planes, kernel_size=3, stride=stride,
                     padding=1, bias=False)


class BasicBlock(nn.Module):
    expansion = 1

    def __init__(self, inplanes, planes, stride=1, downsample=None):
        super(BasicBlock, self).__init__()

        self.conv1 = conv3x3(inplanes, planes, stride)
        self.bn1 = nn.BatchNorm2d(planes)
        self.relu = nn.ReLU(inplace=True)
        self.conv2 = conv3x3(planes, planes)
        self.bn2 = nn.BatchNorm2d(planes)
        self.downsample = downsample

    def forward(self, x):
        residual = x

        out = self.conv1(x)
        out = self.bn1(out)
        out = self.relu(out)

        out = self.conv2(out)
        out = self.bn2(out)

        if self.downsample is not None:
            residual = self.downsample(x)

        out += residual
        out = self.relu(out)

        return out


class Bottleneck(nn.Module):
    expansion = 4

    def __init__(self, inplanes, planes, stride=1, downsample=None):
        super(Bottleneck, self).__init__()
        self.conv1 = nn.Conv2d(inplanes, planes, kernel_size=1, bias=False)
        self.bn1 = nn.BatchNorm2d(planes)
        self.conv2 = nn.Conv2d(planes, planes, kernel_size=3, stride=stride,
                               padding=1, bias=False)
        self.bn2 = nn.BatchNorm2d(planes)
        self.conv3 = nn.Conv2d(planes, planes * 4, kernel_size=1, bias=False)
        self.bn3 = nn.BatchNorm2d(planes * 4)
        self.relu = nn.ReLU(inplace=True)
        self.downsample = downsample
        self.stride = stride

    def forward(self, x):
        residual = x

        out = self.conv1(x)
        out = self.bn1(out)
        out = self.relu(out)

        out = self.conv2(out)
        out = self.bn2(out)
        out = self.relu(out)

        out = self.conv3(out)
        out = self.bn3(out)

        if self.downsample is not None:
            residual = self.downsample(x)

        out += residual
        out = self.relu(out)

        return out

#############################################
# TODO: complete BBoxTransform module       #
#############################################
# [START]

class BBoxTransform(nn.Module):
    def __init__(self, mean=None, std=None):
        super(BBoxTransform, self).__init__()
        if mean is None:
            self.mean = torch.tensor([0, 0, 0, 0], dtype=torch.float32).cuda()
        else:
            self.mean = mean

        if std is None:
            self.std = torch.tensor([0.1, 0.1, 0.2, 0.2], dtype=torch.float32).cuda()
        else:
            self.std = std

    def forward(self, anchors, regression):
        widths = anchors[:, :, 2] - anchors[:, :, 0]
        heights = anchors[:, :, 3] - anchors[:, :, 1]
        ctr_x = anchors[:, :, 0] + 0.5 * widths
        ctr_y = anchors[:, :, 1] + 0.5 * heights

        dx = regression[:, :, 0] * self.std[0] + self.mean[0]
        dy = regression[:, :, 1] * self.std[1] + self.mean[1]
        dw = regression[:, :, 2] * self.std[2] + self.mean[2]
        dh = regression[:, :, 3] * self.std[3] + self.mean[3]

        pred_ctr_x = ctr_x + dx * widths
        pred_ctr_y = ctr_y + dy * heights
        pred_w = torch.exp(dw) * widths
        pred_h = torch.exp(dh) * heights

        x1 = pred_ctr_x - 0.5 * pred_w
        y1 = pred_ctr_y - 0.5 * pred_h
        x2 = pred_ctr_x + 0.5 * pred_w
        y2 = pred_ctr_y + 0.5 * pred_h

        return torch.stack([x1, y1, x2, y2], dim=2)


# [END]

class ClipBoxes(nn.Module):
    def __init__(self, width=None, height=None):
        super(ClipBoxes, self).__init__()

    def forward(self, boxes, img):
        batch_size, num_channels, height, width = img.shape

        boxes[:, :, 0] = torch.clamp(boxes[:, :, 0], min=0)
        boxes[:, :, 1] = torch.clamp(boxes[:, :, 1], min=0)

        boxes[:, :, 2] = torch.clamp(boxes[:, :, 2], max=width)
        boxes[:, :, 3] = torch.clamp(boxes[:, :, 3], max=height)

        return boxes


####################################################################################
# TODO: complete Anchor class, generate_anchors functions and shift function       #
####################################################################################
# generate_anchors():
#   base anchor boxes are generated using the given base size (e.g., 32, 64, …),
#   along with the specified ratios and scales.
# shift():
#   the generated base anchors are then shifted to align with
#   the center of each cell of the feature map.

# [START]
class Anchors(nn.Module):
    def __init__(self, pyramid_levels=None, strides=None, sizes=None, ratios=None, scales=None):
        super(Anchors, self).__init__()
        if pyramid_levels is None:
            self.pyramid_levels = [3, 4, 5, 6, 7]
        if strides is None:
            self.strides = [2 ** x for x in self.pyramid_levels]
        if sizes is None:
            self.sizes = [2 ** (x + 2) for x in self.pyramid_levels]
        if ratios is None:
            self.ratios = np.array([0.5, 1, 2])
        if scales is None:
            self.scales = np.array([2 ** 0, 2 ** (1.0 / 3.0), 2 ** (2.0 / 3.0)])

    def forward(self, image):
        image_shape = image.shape[2:]
        image_shape = np.array(image_shape)
        image_shapes = [(image_shape + 2 ** x - 1) // (2 ** x) for x in self.pyramid_levels]

        # compute anchors over all pyramid levels
        all_anchors = []

        for idx, p in enumerate(self.pyramid_levels):
            anchors = generate_anchors(base_size=self.sizes[idx], ratios=self.ratios, scales=self.scales)
            shifted_anchors = shift(image_shapes[idx], self.strides[idx], anchors)
            all_anchors.append(shifted_anchors)

        all_anchors = np.expand_dims(all_anchors, axis=0)

        return torch.from_numpy(all_anchors.astype(np.float32)).cuda()


def generate_anchors(base_size=16, ratios=None, scales=None):
    if ratios is None:
        ratios = [0.5, 1, 2]
    if scales is None:
        scales = [1, 2, 4]

    num_anchors = len(ratios) * len(scales)
    anchors = np.zeros((num_anchors, 4))
    count = 0
    for scale in scales:
        for ratio in ratios:
            area = base_size * base_size * scale * scale
            w = np.sqrt(area / ratio)
            h = ratio * w
            anchors[count, 0:4] = [-w / 2, -h / 2, w / 2, h / 2]
            count += 1

    return anchors


def shift(shape, stride, anchors):
    shift_x = (np.arange(0, shape[1]) + 0.5) * stride
    shift_y = (np.arange(0, shape[0]) + 0.5) * stride

    shift_x, shift_y = np.meshgrid(shift_x, shift_y)

    shifts = np.vstack((
        shift_x.ravel(), shift_y.ravel(),
        shift_x.ravel(), shift_y.ravel()
    )).transpose()

    A = anchors.shape[0]
    K = shifts.shape[0]
    all_anchors = anchors.reshape((1, A, 4)) + shifts.reshape((K, 1, 4))
    all_anchors = all_anchors.reshape((K * A, 4))

    return all_anchors

# [END]


class ResNet(nn.Module):
    def __init__(self, num_classes, block, layers):
        self.inplanes = 64
        super(ResNet, self).__init__()
        self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False)
        self.bn1 = nn.BatchNorm2d(64)
        self.relu = nn.ReLU(inplace=True)
        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)
        self.layer1 = self._make_layer(block, 64, layers[0])
        self.layer2 = self._make_layer(block, 128, layers[1], stride=2)
        self.layer3 = self._make_layer(block, 256, layers[2], stride=2)
        self.layer4 = self._make_layer(block, 512, layers[3], stride=2)

        if block == BasicBlock:
            fpn_sizes = [self.layer2[layers[1] - 1].conv2.out_channels, self.layer3[layers[2] - 1].conv2.out_channels,
                         self.layer4[layers[3] - 1].conv2.out_channels]
        elif block == Bottleneck:
            fpn_sizes = [self.layer2[layers[1] - 1].conv3.out_channels, self.layer3[layers[2] - 1].conv3.out_channels,
                         self.layer4[layers[3] - 1].conv3.out_channels]
        else:
            raise ValueError(f"Block type {block} not understood")

        ####################################################################################
        # TODO: fill the components.                                                       #
        ####################################################################################
        # [START]

        self.fpn = PyramidFeatures(fpn_sizes[0], fpn_sizes[1], fpn_sizes[2])

        self.regressionModel = RegressionModel(256)
        self.classificationModel = ClassificationModel(256, num_classes=num_classes)

        self.anchors = Anchors()

        self.regressBoxes = BBoxTransform()


        # [END]

        self.clipBoxes = ClipBoxes()

        self.lossModule = None

        for m in self.modules():
            if isinstance(m, nn.Conv2d):
                n = m.kernel_size[0] * m.kernel_size[1] * m.out_channels
                m.weight.data.normal_(0, math.sqrt(2. / n))
            elif isinstance(m, nn.BatchNorm2d):
                m.weight.data.fill_(1)
                m.bias.data.zero_()

        prior = 0.01

        self.classificationModel.output.weight.data.fill_(0)
        self.classificationModel.output.bias.data.fill_(-math.log((1.0 - prior) / prior))

        self.regressionModel.output.weight.data.fill_(0)
        self.regressionModel.output.bias.data.fill_(0)

        self.freeze_bn()

    def _make_layer(self, block, planes, blocks, stride=1):
        downsample = None
        if stride != 1 or self.inplanes != planes * block.expansion:
            downsample = nn.Sequential(
                nn.Conv2d(self.inplanes, planes * block.expansion,
                          kernel_size=1, stride=stride, bias=False),
                nn.BatchNorm2d(planes * block.expansion),
            )

        layers = [block(self.inplanes, planes, stride, downsample)]
        self.inplanes = planes * block.expansion
        for i in range(1, blocks):
            layers.append(block(self.inplanes, planes))

        return nn.Sequential(*layers)

    def freeze_bn(self):
        '''Freeze BatchNorm layers.'''
        for layer in self.modules():
            if isinstance(layer, nn.BatchNorm2d):
                layer.eval()

    def forward(self, inputs):
        if self.training:
            img_batch, annotations = inputs
        else:
            img_batch = inputs

        print("\n[DEBUG][forward()]")
        print(f"img_batch shape: {img_batch.shape}, dtype: {img_batch.dtype}")
        print(f"annot_batch shape: {annot_batch.shape}, dtype: {annot_batch.dtype}")
        for i in range(annot_batch.shape[0]):
          print(f"  annot[{i}] shape = {annot_batch[i].shape}, values = {annot_batch[i]}")


        x = self.conv1(img_batch)
        x = self.bn1(x)
        x = self.relu(x)
        x = self.maxpool(x)

        x1 = self.layer1(x)
        x2 = self.layer2(x1)
        x3 = self.layer3(x2)
        x4 = self.layer4(x3)

        features = self.fpn([x2, x3, x4])

        regression = torch.cat([self.regressionModel(feature) for feature in features], dim=1)

        classification = torch.cat([self.classificationModel(feature) for feature in features], dim=1)

        anchors = self.anchors(img_batch)

        if self.training:
            return self.lossModule(classification, regression, anchors, annotations)
        else:
            transformed_anchors = self.regressBoxes(anchors, regression)
            transformed_anchors = self.clipBoxes(transformed_anchors, img_batch)

            finalResult = [[], [], []]

            finalScores = torch.Tensor([])
            finalAnchorBoxesIndexes = torch.Tensor([]).long()
            finalAnchorBoxesCoordinates = torch.Tensor([])

            finalScores = finalScores.cuda()
            finalAnchorBoxesIndexes = finalAnchorBoxesIndexes.cuda()
            finalAnchorBoxesCoordinates = finalAnchorBoxesCoordinates.cuda()

            for i in range(classification.shape[2]):
                scores = torch.squeeze(classification[:, :, i])
                scores_over_thresh = (scores > 0.05)
                if scores_over_thresh.sum() == 0:
                    # no boxes to NMS, just continue
                    continue

                scores = scores[scores_over_thresh]
                anchorBoxes = torch.squeeze(transformed_anchors)
                anchorBoxes = anchorBoxes[scores_over_thresh]
                anchors_nms_idx = nms(anchorBoxes, scores, 0.5)

                finalResult[0].extend(scores[anchors_nms_idx])
                finalResult[1].extend(torch.tensor([i] * anchors_nms_idx.shape[0]))
                finalResult[2].extend(anchorBoxes[anchors_nms_idx])

                finalScores = torch.cat((finalScores, scores[anchors_nms_idx]))
                finalAnchorBoxesIndexesValue = torch.tensor([i] * anchors_nms_idx.shape[0])
                finalAnchorBoxesIndexesValue = finalAnchorBoxesIndexesValue.cuda()

                finalAnchorBoxesIndexes = torch.cat((finalAnchorBoxesIndexes, finalAnchorBoxesIndexesValue))
                finalAnchorBoxesCoordinates = torch.cat((finalAnchorBoxesCoordinates, anchorBoxes[anchors_nms_idx]))

            return [finalScores, finalAnchorBoxesIndexes, finalAnchorBoxesCoordinates]


def resnet101(num_classes, pretrained=False, **kwargs):
    """Constructs a ResNet-101 model.
    Args:
        pretrained (bool): If True, returns a model pre-trained on ImageNet
    """
    model = ResNet(num_classes, Bottleneck, [3, 4, 23, 3], **kwargs)
    if pretrained:
        model.load_state_dict(model_zoo.load_url(model_urls['resnet101'], model_dir='.'), strict=False)
    return model

retinanet = resnet101(num_classes=dataset_train.num_classes(), pretrained=True)
retinanet = retinanet.cuda()
#cuda(): GPU 메모리로 tnesor를 올리는 함수

optimizer = optim.Adam(retinanet.parameters(), lr=1e-5)
scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=3, verbose=True)

"""## Train: BCE Loss
---
Implement the training step

"""

def calc_iou(a, b):
    area = (b[:, 2] - b[:, 0]) * (b[:, 3] - b[:, 1])

    iw = torch.min(torch.unsqueeze(a[:, 2], dim=1), b[:, 2]) - torch.max(torch.unsqueeze(a[:, 0], 1), b[:, 0])
    ih = torch.min(torch.unsqueeze(a[:, 3], dim=1), b[:, 3]) - torch.max(torch.unsqueeze(a[:, 1], 1), b[:, 1])

    iw = torch.clamp(iw, min=0)
    ih = torch.clamp(ih, min=0)

    ua = torch.unsqueeze((a[:, 2] - a[:, 0]) * (a[:, 3] - a[:, 1]), dim=1) + area - iw * ih

    ua = torch.clamp(ua, min=1e-8)

    intersection = iw * ih

    IoU = intersection / ua

    return IoU

class BinaryCrossEntropyLoss(nn.Module):
    def forward(self, classifications, regressions, anchors, annotations):
        batch_size = classifications.shape[0]
        classification_losses = []
        regression_losses = []

        anchor = anchors[0, :, :]

        anchor_widths  = anchor[:, 2] - anchor[:, 0]
        anchor_heights = anchor[:, 3] - anchor[:, 1]
        anchor_ctr_x   = anchor[:, 0] + 0.5 * anchor_widths
        anchor_ctr_y   = anchor[:, 1] + 0.5 * anchor_heights

        for j in range(batch_size):

            classification = classifications[j, :, :]
            regression = regressions[j, :, :]

            bbox_annotation = annotations[j, :, :]
            bbox_annotation = bbox_annotation[bbox_annotation[:, 4] != -1]

            classification = torch.clamp(classification, 1e-4, 1.0 - 1e-4)

            IoU = calc_iou(anchors[0, :, :], bbox_annotation[:, :4]) # num_anchors x num_annotations

            IoU_max, IoU_argmax = torch.max(IoU, dim=1) # num_anchors x 1

            # compute the loss for classification
            targets = torch.ones(classification.shape) * -1
            targets = targets.cuda()

            targets[torch.lt(IoU_max, 0.4), :] = 0

            positive_indices = torch.ge(IoU_max, 0.5)
            num_positive_anchors = positive_indices.sum()

            assigned_annotations = bbox_annotation[IoU_argmax, :]


            targets[positive_indices, :] = 0
            targets[positive_indices, assigned_annotations[positive_indices, 4].long()] = 1

            bce = -(targets * torch.log(classification) + (1.0 - targets) * torch.log(1.0 - classification))

            cls_loss = bce
            cls_loss = torch.where(torch.ne(targets, -1.0), cls_loss, torch.zeros(cls_loss.shape).cuda())
            classification_losses.append(cls_loss.sum()/torch.clamp(num_positive_anchors.float(), min=1.0))

            # compute the loss for regression
            if positive_indices.sum() > 0:
                assigned_annotations = assigned_annotations[positive_indices, :]

                anchor_widths_pi = anchor_widths[positive_indices]
                anchor_heights_pi = anchor_heights[positive_indices]
                anchor_ctr_x_pi = anchor_ctr_x[positive_indices]
                anchor_ctr_y_pi = anchor_ctr_y[positive_indices]

                gt_widths  = assigned_annotations[:, 2] - assigned_annotations[:, 0]
                gt_heights = assigned_annotations[:, 3] - assigned_annotations[:, 1]
                gt_ctr_x   = assigned_annotations[:, 0] + 0.5 * gt_widths
                gt_ctr_y   = assigned_annotations[:, 1] + 0.5 * gt_heights

                # clip widths to 1
                gt_widths  = torch.clamp(gt_widths, min=1)
                gt_heights = torch.clamp(gt_heights, min=1)

                targets_dx = (gt_ctr_x - anchor_ctr_x_pi) / anchor_widths_pi
                targets_dy = (gt_ctr_y - anchor_ctr_y_pi) / anchor_heights_pi
                targets_dw = torch.log(gt_widths / anchor_widths_pi)
                targets_dh = torch.log(gt_heights / anchor_heights_pi)

                print(f"[DEBUG][targets stack] dx shape: {targets_dx.shape}")
                print(f"[DEBUG][targets stack] dy shape: {targets_dy.shape}")
                print(f"[DEBUG][targets stack] dw shape: {targets_dw.shape}")
                print(f"[DEBUG][targets stack] dh shape: {targets_dh.shape}")


                targets = torch.stack((targets_dx, targets_dy, targets_dw, targets_dh))
                targets = targets.t()

                targets = targets/torch.Tensor([[0.1, 0.1, 0.2, 0.2]]).cuda()

                regression_diff = torch.abs(targets - regression[positive_indices, :])

                regression_loss = torch.where(
                    torch.le(regression_diff, 1.0 / 9.0),
                    0.5 * 9.0 * torch.pow(regression_diff, 2),
                    regression_diff - 0.5 / 9.0
                )
                regression_losses.append(regression_loss.mean())
            else:
                regression_losses.append(torch.tensor(0).float().cuda())

        return torch.stack(classification_losses).mean(dim=0, keepdim=True), torch.stack(regression_losses).mean(dim=0, keepdim=True)

retinanet.lossModule = BinaryCrossEntropyLoss()
retinanet.train()
retinanet.freeze_bn()

print('Num training images: {}'.format(len(dataset_train)))

for epoch_num in range(20):
    retinanet.train()
    retinanet.freeze_bn()
    epoch_loss = []

    for iter_num, data in enumerate(dataloader_train):
        #############################################
        # TODO: complete following training steps   #
        #############################################
        # [START]
        optimizer.zero_grad()

        img_batch = data['img'].cuda().float()
        #cuda(): pytorch에서 tensor를 GPU로 올릴 때 사용하는 함수
        annot_batch = data['annot'].cuda().float()

        for i in range(annot_batch.shape[0]):
          valid_annots = annot_batch[i][annot_batch[i, :, 0] >= 0]  # x1 >= 0 인 것만

        if valid_annots.shape[0] == 0:
          continue  # 이 이미지엔 실제 객체가 없음

        print("annot shape:", annot_batch.shape)
        classification_loss, regression_loss = retinanet((img_batch, annot_batch))
        loss = classification_loss + regression_loss

        if bool(loss == 0):
            continue

        loss.backward()
        optimizer.step()

        epoch_loss.append(float(loss))

        print('Epoch: {} | Iteration: {} | Classification loss: {:1.5f} | Regression loss: {:1.5f}'.format(epoch_num, iter_num, float(classification_loss), float(regression_loss)))

        del classification_loss
        del regression_loss
        torch.cuda().empty_cache()

        # [END]

    scheduler.step(np.mean(epoch_loss))

retinanet.eval()
torch.save(retinanet, 'model_final_BCE.pt')

"""## Load trained RetinaNet and perform inference
---
Let's compare the ground truth and the model's predictions.
"""

retinanet = torch.load('model_final_BCE.pt', weights_only=False, map_location='cpu')
retinanet = retinanet.cuda()
retinanet.eval()

"""##### Ground truth"""

sample = dataset_val[123]
print(type(sample['img']))
show_sample(sample=sample, GT=True)

"""##### Prediction"""

sample = dataset_val[123]
print(type(sample['img']))
show_sample(sample=sample, GT=False, model=retinanet)

"""## Focal loss
---
Let's use Focal Loss instead of BCE Loss.    

In object detection, the background is much more prevalent than the objects, which makes the background an easier target to predict. [Focal loss](https://arxiv.org/pdf/1708.02002) was proposed to address this issue by, compared to BCE loss, assigning a smaller loss to well-classified targets (background) and a larger loss to hard-to-classify samples (objects), thereby mitigating the imbalance problem.
"""

class FocalLoss(nn.Module):
    def forward(self, classifications, regressions, anchors, annotations):
        alpha = 0.25
        gamma = 2.0
        batch_size = classifications.shape[0]
        classification_losses = []
        regression_losses = []

        anchor = anchors[0, :, :]

        anchor_widths  = anchor[:, 2] - anchor[:, 0]
        anchor_heights = anchor[:, 3] - anchor[:, 1]
        anchor_ctr_x   = anchor[:, 0] + 0.5 * anchor_widths
        anchor_ctr_y   = anchor[:, 1] + 0.5 * anchor_heights

        for j in range(batch_size):

            classification = classifications[j, :, :]
            regression = regressions[j, :, :]

            bbox_annotation = annotations[j, :, :]
            bbox_annotation = bbox_annotation[bbox_annotation[:, 4] != -1]



            if bbox_annotation.shape[0] == 0:
              bbox_annotation = torch.zeros((1, 5)).cuda()

            classification = torch.clamp(classification, 1e-4, 1.0 - 1e-4)

            IoU = calc_iou(anchors[0, :, :], bbox_annotation[:, :4]) # num_anchors x num_annotations

            IoU_max, IoU_argmax = torch.max(IoU, dim=1) # num_anchors x 1

            # compute the loss for classification
            targets = torch.ones(classification.shape) * -1
            targets = targets.cuda()

            targets[torch.lt(IoU_max, 0.4), :] = 0

            positive_indices = torch.ge(IoU_max, 0.5)
            num_positive_anchors = positive_indices.sum()

            assigned_annotations = bbox_annotation[IoU_argmax, :]

            targets[positive_indices, :] = 0
            targets[positive_indices, assigned_annotations[positive_indices, 4].long()] = 1

            alpha_factor = torch.ones(targets.shape).cuda() * alpha
            alpha_factor = torch.where(torch.eq(targets, 1.), alpha_factor, 1. - alpha_factor)

            focal_weight = torch.where(torch.eq(targets, 1.), 1. - classification, classification)
            focal_weight = alpha_factor * torch.pow(focal_weight, gamma)

            bce = -(targets * torch.log(classification) + (1.0 - targets) * torch.log(1.0 - classification))

            cls_loss = focal_weight * bce
            cls_loss = torch.where(torch.ne(targets, -1.0), cls_loss, torch.zeros(cls_loss.shape).cuda())
            classification_losses.append(cls_loss.sum()/torch.clamp(num_positive_anchors.float(), min=1.0))

            # compute the loss for regression
            if positive_indices.sum() > 0:
                assigned_annotations = assigned_annotations[positive_indices, :]

                anchor_widths_pi = anchor_widths[positive_indices]
                anchor_heights_pi = anchor_heights[positive_indices]
                anchor_ctr_x_pi = anchor_ctr_x[positive_indices]
                anchor_ctr_y_pi = anchor_ctr_y[positive_indices]

                gt_widths  = assigned_annotations[:, 2] - assigned_annotations[:, 0]
                gt_heights = assigned_annotations[:, 3] - assigned_annotations[:, 1]
                gt_ctr_x   = assigned_annotations[:, 0] + 0.5 * gt_widths
                gt_ctr_y   = assigned_annotations[:, 1] + 0.5 * gt_heights

                # clip widths to 1
                gt_widths  = torch.clamp(gt_widths, min=1)
                gt_heights = torch.clamp(gt_heights, min=1)

                targets_dx = (gt_ctr_x - anchor_ctr_x_pi) / anchor_widths_pi
                targets_dy = (gt_ctr_y - anchor_ctr_y_pi) / anchor_heights_pi
                targets_dw = torch.log(gt_widths / anchor_widths_pi)
                targets_dh = torch.log(gt_heights / anchor_heights_pi)

                targets = torch.stack((targets_dx, targets_dy, targets_dw, targets_dh))
                targets = targets.t()

                targets = targets/torch.Tensor([[0.1, 0.1, 0.2, 0.2]]).cuda()

                regression_diff = torch.abs(targets - regression[positive_indices, :])

                regression_loss = torch.where(
                    torch.le(regression_diff, 1.0 / 9.0),
                    0.5 * 9.0 * torch.pow(regression_diff, 2),
                    regression_diff - 0.5 / 9.0
                )
                regression_losses.append(regression_loss.mean())
            else:
                regression_losses.append(torch.tensor(0).float().cuda())

        return torch.stack(classification_losses).mean(dim=0, keepdim=True), torch.stack(regression_losses).mean(dim=0, keepdim=True)

try:
    del retinanet
except:
    pass

torch.cuda.empty_cache()

retinanet_FL = resnet101(num_classes=dataset_train.num_classes(), pretrained=True)
retinanet_FL = retinanet_FL.cuda()

optimizer = optim.Adam(retinanet_FL.parameters(), lr=1e-5)
scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=3, verbose=True)

retinanet_FL.lossModule = FocalLoss()
retinanet_FL.train()
retinanet_FL.freeze_bn()

print('Num training images: {}'.format(len(dataset_train)))
for epoch_num in range(20):
    retinanet_FL.train()
    retinanet_FL.freeze_bn()
    epoch_loss = []

    for iter_num, data in enumerate(dataloader_train):
        #############################################
        # TODO: complete following training steps   #
        #############################################
        # [START]

        epoch_loss.append(float(loss))

        print('Epoch: {} | Iteration: {} | Classification loss: {:1.5f} | Regression loss: {:1.5f}'.format(epoch_num, iter_num, float(classification_loss), float(regression_loss)))

        del classification_loss
        del regression_loss

        # [END]

    scheduler.step(np.mean(epoch_loss))

retinanet_FL.eval()
torch.save(retinanet_FL, 'model_final_FL.pt')

"""## Load trained RetinaNet and infer
---
Let's compare the ground truth and the model's predictions.
"""

retinanet_FL = torch.load('model_final_FL.pt', weights_only=False, map_location='cpu')
retinanet_FL = retinanet_FL.cuda()
retinanet_FL.eval()

"""##### Ground truth"""

sample = dataset_val[123]
print(type(sample['img']))
show_sample(sample=sample, GT=True)

"""##### Prediction"""

sample = dataset_val[123]
print(type(sample['img']))
show_sample(sample=sample, GT=False, model=retinanet_FL)